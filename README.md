# Smart Containers

[![Join the chat at https://gitter.im/charlesvardeman/sc_spec](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/charlesvardeman/sc_spec)

## Table of contents

 1. [Quick intro](#quick-intro)
 2. [Brief example of Smart Containers in action](#brief-example-of-solid-in-action)
 3. [RDF](#rdf)
 4. [Ontologies](#Ontologies)
 4. [Reading and writing data using LDP](#reading-and-writing-data-using-ldp)
 5. [Reading and writing data using SPARQL](#reading-and-writing-data-using-sparql)
 8. [Identity management](#identity-management-based-on-webid)
 9. [Personal data workspaces](#personal-data-workspaces)
 10. [Authentication](#authentication)
 11. [Access control](#access-control)
 12 [Software implementing SmartContainers](#software-implementing-solid)

Specification for Smart Containers

## Quick Intro
Scientists need an efficient approach to preserve and share the results of computational work and in fact, is required by reproducibility requirements of the scientific process. Although a variety of technologies have been created to capture computational experiments, it is still a struggle for scientists to understand the preserved experiment without a detailed documentation and context of the results being shared. Smart Container (SC) is a modular specification and implementation that leverages linked data principles to enable the preservation, sharing and reuse of both software and data artifacts.

Smart Containers begin with conceptualizing computational experiments from the perspective of computational environments and activities within those environments as provided by the Docker Linux container framework. Docker is a lightweight virtualization platform that has several properties such as versioning of file system operations, a modular design for distribution of software components as well as a sustainable community that make it attractive as a preservation tool. One community of collaborators at CERN is already exploring Docker to preserve high energy physics experiments. Our approach is to eventually provide a mechanism that captures the additional provenance of computational experiments in a machine readable approach using the W3C standard RDF data model that has been shown to aid in contextualization of scientific experiment.

By starting with a formal model of Docker and the provenance of Docker activities, we hope to provide a basis for 1) existing scientific workflow frameworks and their workflow descriptions to be captured within a Linux container environment 2) data to be integrated in a consistent manner and lastly 3) for a common description of the environment. The ultimate goal being to provide automated tools that “wrap” the existing Docker command line tool and infrastructure such that it is transparent to the scientist but captures information necessary to populate the metadata behind the scenes. Automated scientific gateways that utilize Docker as a deployment and execution platform would provide a further degree of transparency and allow researchers a low barrier for utilization.

Features:


## Brief Example of SmartContainers in action


## Docker
[Docker](https://www.docker.com/) is an application that encapsulates and extends a Linux Kernel feature known as Linux Containers (LXC). It isolates an application with its dependencies in a single process which is more light-weighted than full hypervisor virtualization of guest OS. It can be provisioned by a simple Dockerfile text based workflow. Docker also adopted a layer file system way to achieve versioning and component re-use. A Docker image is a read-only layer which is stateless. A container has states: when it is running, it represents a tree of processes isolated from other processes on the host; when it exits, it represents a read-write layer generated by the process along with its all underneath stateless images.

### Existing Metadata in Docker
Docker includes metadata attached to images and containers and may be accessed through the Docker [inspect](https://docs.docker.com/reference/commandline/inspect/) command. Docker inspect returns a JSON array.  

```bash
docker inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...]

```

Individual fields of the JSON key-value structure may also be searched. For example.
```bash
$ docker inspect --format='{{.NetworkSettings.IPAddress}}' $INSTANCE_ID
```

Metadata is stored by Docker in the */var/lib/docker* directory on the host machine. The exact directory depends on the storage driver.
You can manually set the storage driver with the -s or --storage-driver= option to the Docker daemon.

`/var/lib/docker/{driver-name}` will contain the driver specific storage for contents of the images.
`/var/lib/docker/graph/<id>` now only contains metadata about the image, in the json and layersize files.
In the case of aufs:

`/var/lib/docker/aufs/diff/<id>` has the file contents of the images.
`/var/lib/docker/repositories-aufs` is a JSON file containing local image information. This can be viewed with the command docker images.
In the case of devicemapper:

`/var/lib/docker/devicemapper/devicemapper/data` stores the images
`/var/lib/docker/devicemapper/devicemapper/metadata` the metadata
Note these files are thin provisioned "sparse" files so aren't as big as they seem.

Docker's behavior and output formats may also be modified through the [*config.json*](https://docs.docker.com/reference/commandline/cli/) file that specifies default behavior of the command line as well as formatting options for command results.

Metadata is set through the Docker [label](https://docs.docker.com/userguide/labels-custom-metadata/) *command line option to other commands* that provides a `<key>/<value>` pair. Unfortunately, Docker doesn't provide a direct means of modifying or adding labels to containers or images other than using the run command. For example


```bash
LABEL com.example.image-specs="{\"Description\":\"A containerized foobar\",\"Usage\":\"docker run --rm example\\/foobar [args]\",\"License\":\"GPL\",\"Version\":\"0.0.1-beta\",\"aBoolean\":true,\"aNumber\":0.01234,\"aNestedArray\":[\"a\",\"b\",\"c\"]}"
```
Docker labels may also be specified as a command field in a **Dockerfile** which will be instantiated during the docker [build](https://docs.docker.com/reference/builder/) command. For example:
```
LABEL com.example.label-with-value="foo"
LABEL version="1.0"
LABEL description="This text illustrates \
that label-values can span multiple lines."
```

Docker provides some brief guidelines for constructing labels as follows:
To prevent naming conflicts, Docker namespaces label keys using a reverse domain notation. Use the following guidelines to name your keys:

+ All (third-party) tools should prefix their keys with the reverse DNS notation of a domain controlled by the author. For example, com.example.some-label.
+ The com.docker.*, io.docker.* and org.dockerproject.* namespaces are reserved for Docker’s internal use.
+ Keys should only consist of lower-cased alphanumeric characters, dots and dashes (for example, [a-z0-9-.])
+ Keys should start and end with an alpha numeric character
+ Keys may not contain consecutive dots or dashes.
+ Keys without namespace (dots) are reserved for CLI use. This allows end- users to add metadata to their containers and images without having to type cumbersome namespaces on the command-line.

Smart Containers relies on this ability to attach metadata to a container or image. Since a label may be an JSON array, Smart Containers attaches a **JSON-LD** serialization of the graph object to the Docker container. All of the previous provenance history of a Docker Object (image/container) is encoded using RDF/OWL based vocabularies.

## RDF
The Resource Description Framework (RDF) is a framework for representing and linking data within the World Wide Web infrastructure [[RDF1.1](http://www.w3.org/TR/rdf11-concepts/)], and is a graph-based data model, where the core structure of the abstract syntax is a set of triples, each consisting of a subject, a predicate and an object. The idea is that we want relationship identifiers that form a "Knowledge Graph" and represent [things not strings](https://googleblog.blogspot.com/2012/05/introducing-knowledge-graph-things-not.html).
![](https://github.com/charlesvardeman/sc_spec/blob/master/assets/rdf-graph.svg)

There are several serialization syntaxes for storing and exchanging RDF such as [Turtle](http://www.w3.org/TR/turtle/) and [JSON-LD](http://www.w3.org/TR/json-ld/). When creating new RDF resources, Turtle is regarded as a more human *readable* serialization although JSON-LD has the advantage of being . Servers should implement content negotiation in order to handle different serialization formats.


## Linked Data Principles
Tim Berners-Lee published a [technical note](http://www.w3.org/DesignIssues/LinkedData.html) outlining some basic principles for publishing data on the Web. These principles can be summarized as:

1. Use URIs as names for things.
2. Use HTTP URIs so that people can look up those names.
3. When someone looks up a URI, provide useful information, using the standards (RDF*, SPARQL)
4. Include links to other URIs. so that they can discover more things.

Data that adopts some of these principles is referred to as *"Five Star"* linked data. The [W3C](http://www.w3.org/standards/semanticweb/data) continues to create [recommendations](http://www.w3.org/standards/techs/linkeddata#w3c_all) to facilitate the linked data vision. The [BBC](http://www.bbc.co.uk/blogs/radiolabs/s5/linked-data/s5.html) has a nice introduction to linked data principles.
## Ontologies

## Persistent Identifiers and minting URIs
CoolURIs, Trusty URI's WebID ORCID and RDA PID group work.
